\csection{Введение}
Робот производит торговлю несколькими портфелями одновременно, параметры портфелей приведены ниже. Параметры делятся на редактируемые (т.е. собственно настройки) и
отображаемые или расчетные (например, финансовый результат). Параметры портфеля -- это параметры отображаемые в таблице на главном окне робота и в окне редактирования настроек
портфеля НЕ в таблице, параметры инструментов портфеля -- это параметры отображаемые в таблице в окне редактирования настроек портфеля. Параметры уведомлений портфеля -- это
редактируемые параметры, отображаемые в окне настроек уведомлений портфеля.


\csection{Параметры портфеля (редактируемые)}
\begin{enumerate}
	\item \textbf{Name} -- имя портфеля (всегда НЕ редактируемое, т.к. является уникальным ключем);
	\item \textbf{re\_sell} -- разрешена продажа (при взведении флага включает робот на продажу);
	\item \textbf{re\_buy} -- разрешена покупка (при взведении флага включает робот на покупку);
	\item \textbf{v\_in\_left}\hyperref[comment0]{\ref{comment0}\textsuperscript{0}} -- минимальный разрешенный объем для входа в позицию (в штуках портфелей);
	\item \textbf{v\_in\_right}\hyperref[comment0]{\ref{comment0}\textsuperscript{0}} -- максимальный разрешенный объем для входа в позицию (в штуках портфелей);
	\item \textbf{v\_out\_left}\hyperref[comment0]{\ref{comment0}\textsuperscript{0}} -- минимальный разрешенный объем для выхода из позиции (в штуках портфелей), разрешено выставление меньшим объемом в случае сведения
		позиции к нулю данной заявкой;
	\item \textbf{v\_out\_right}\hyperref[comment0]{\ref{comment0}\textsuperscript{0}} -- максимальный разрешенный объем для выхода из позиции (в штуках портфелей);
	\item \textbf{Virtual 0 pos}\hyperref[comment0]{\ref{comment0}\textsuperscript{0}} -- котирующая заявка по $Is \; first$ бумаге с направлением в сторону закрытия позиции может не только сводить позицию к нулю,
		но и сразу открывать новую позицию с противоположным направлением, кроме того объем заявки никогда не может быть меньше $v\_in\_left$ или $v\_out\_left$;
	\item \textbf{Delta} -- минимальное отклонение $Price\_s$ и $Price\_b$ от цены выставленной заявки на продажу или покупку, соответственно, при превышении
		которого необходимо переставить котируемую заявку, то есть заявку по $Is \; first$ инструменту (используется только при включенном режиме $Quote$);
	\item \textbf{Pos}\hyperref[comment1]{\ref{comment1}\textsuperscript{1}} -- текущая позиция портфеля (в штуках портфелей), вычисляется по формуле
		$Pos=[Curpos_{first} / Count_{first}]$, где $Curpos_{first}$ и $Count_{first}$ -- это параметры $Curpos$ и $Count$ для инструмента портфеля с взведенным флагом
		$Is \; first$;
	\item \textbf{Lim\_Sell} -- сигнальная цена на продажу, заявка по $Is \; first$ бумаге выставляется если $Sell \geq Lim\_Sell$ в не зависимости от того включен или нет
		режим $Quote$;
	\item \textbf{Lim\_Buy} -- сигнальная цена на покупку, заявка по $Is \; first$ бумаге выставляется если $Buy \leq Lim\_Buy$ в не зависимости от того включен или нет
		режим $Quote$;
	\item \textbf{First delta} -- задается в процентах (\%), котируемая заявка переставляется если ее текущий не исполненный объем меньше, чем $First \; delta$ от
		первоначального выставленного объема (используется только при включенном режиме $Quote$);
	\item \textbf{Market volume} -- максимальное количество лотов по лучшей цене на продажу или покупку (или суммарное количество лотов в стакане до
		''нашей'' предполагаемой цены если $Type \; price = Orderbook$ или $Type \; price = Orderbook + filter$), соответственно, при котором выставляется заявка по $Is \; first$
		бумаге, при условии, что заявка выставляется не в спред, если цена заявки попадает в спред то значение данного параметра не используется;
	\item \textbf{Price check} -- если предполагаемая цена выставления заявки по $Is \; first$ бумаге попадает в стакан глубже, чем на $Price \; check$
		пунктов, то не выставляться (то есть если $offer + Price \; check < Price\_s$, где $offer$ --
		лучшая цена на продажу $Is \; first$ инструмента, то не выставляться, для покупки аналогично);
	\item \textbf{v\_min}\hyperref[comment1]{\ref{comment1}\textsuperscript{1}} -- минимальная разрешенная позиция для главного инструмента портфеля (в лотах);
	\item \textbf{v\_max}\hyperref[comment1]{\ref{comment1}\textsuperscript{1}} -- максимальная разрешенная позиция для главного инструмента портфеля (в лотах);
	\item \textbf{Quote} -- котировать инструмент, если включено, то заявка всегда держится в стакане, если выключено, то заявка на продажу выставляется когда $Sell \geq Lim\_Sell$,
		заявка на покупку выставляется когда $Buy \leq Lim\_Buy$;
	\item \textbf{Limits timer} -- время таймера, таймер включается если торговля включена и проходит сигнал на покупку/продажу, но торговля запрещена из-за того, что позиция
		($Curpos$) по главной бумаге равна $v\_max$ или $v\_min$, соответственно;
	\item \textbf{Percent} -- используется при срабатывании $Limits \; timer$, если сигнал на торговлю продержался $Percent$ процентов времени $Limits \; timer$ то $Lim\_Sell$ и $Lim\_Buy$
		передвигаются на $K$, не смотря на отсутствие сделок по $Is \; first$ бумаге;
	\item \textbf{Use timetable} -- использовать торговлю по расписанию, расписание представляет собой список групп параметров:
		\begin{enumerate}
			\item \textbf{Begin} -- начало торгового периода;
			\item \textbf{End} -- окончание торгового периода;
			\item \textbf{Close} -- попытаться закрыть позицию сразу после окончания торгового периода;
			\item \textbf{To market} -- попытаться выровнять позицию сразу после окончания торгового периода;
			\item \textbf{To0} -- использовать \textit{To0} в данный период;
		\end{enumerate}
		если текущее локальное время на компьютере ($curTime$) попадает в один из периодов, т.е. $Begin_i \leq curTime \leq End_i$, то $re\_sell$ и
		$re\_buy$ включаются автоматически (кроме режима \textit{Timetable only stop}), в противном случае (если текущее время не попадает ни в один из периодов) $re\_sell$ и $re\_buy$ выключаются автоматически;
	\item \textbf{Timetable only stop} -- автоматически выключать торговлю если текущее время не попадает в периоды расписания, но при этом автоматически не включать торговлю если время попадает в один из периодов расписания;
	\item \textbf{To0}\hyperref[comment0]{\ref{comment0}\textsuperscript{0}} -- если флаг взведен, то не открывать позицию, а только закрывать и не открываться из нулевой позиции;
	\item \textbf{Opened} -- параметр, используемый для подсчета финансового результата, вычисляется по формуле:
		\begin{align*}
		Opened = -\left( \sum_{i \in bought} tradePrice_i \times tradeAmount_i \times Mult_i \right) + \\ \left( \sum_{i \in sold} tradePrice_i \times tradeAmount_i \times Mult_i \right),
		\end{align*} 
		где $tradePrice_i$ -- цена сделки, а $tradeAmount_i$ -- количество лотов в сделке, $bought$ -- список
		сделок на покупку, $sold$ -- список сделок на продажу, $Mult$ -- $Fin \; res \; multiplier$ инструмента портфеля;
	\item \textbf{Commission sum} -- сумма комиссии по всем сделкам портфеля, используется для подсчета финансового результата;
	\item \textbf{Decimals} -- параметр, определяющий сколько знаков после десятичной точки отображается в параметрах, для которых значение является дробным числом;
	\item \textbf{In formulas} -- флаг, если взведен, то портфель и его инструменты могут использоваться в формулах на C++ (рекомендуется снимать данный флаг для ненужных в формулах портфелей, это ускоряет работу робота);
	\item \textbf{Disabled} -- полностью выключить портфель из всех расчетов и торговли не удаляя его;
	\item \textbf{Sell clicker} -- ''кликер'', выставить заявку на продажу заданного в количестве портфелей объема;
	\item \textbf{Buy clicker} -- ''кликер'', выставить заявку на покупку заданного в количестве портфелей объема;
	\item \textbf{To market} -- ''кликер'', снять все заявки и выставить их по рыночным ценам (с учетом параметра $k\_sl$) и выровнять позицию;
	%\item \textbf{Log level} -- уровень логирование работы торгового алгоритма;
	\item \textbf{K}\hyperref[comment2]{\ref{comment2}\textsuperscript{2}} -- параметр, используемый для смещения значений $Lim\_Sell$ и $Lim\_Buy$ (пример использования
		описан ниже);
	\item \textbf{K1}\hyperref[comment2]{\ref{comment2}\textsuperscript{2}} -- параметр, используемый для смещения значений $Lim\_Sell$ и $Lim\_Buy$ (пример использования
		описан ниже);
	\item \textbf{K2} -- параметр, используемый для смещения значений $Lim\_Sell$ и $Lim\_Buy$ (пример использования описан ниже);
	\item \textbf{TP} -- параметр, используемый для смещения значений $Lim\_Sell$ и $Lim\_Buy$ (пример использования описан ниже);
	\item \textbf{Order ID} -- идентификатор всех заявок портфеля, так же определяет приоритет вызова торгового алгоритма портфеля. Рассмотрим пример, пусть есть несколько портфелей
		и во всех этих портфелях есть один и тот же инструмент. При изменении цены или объема лучшей цены на покупку/продажу по данному инструменту вызывается алгоритм
		торговли по всем портфелям, в которых этот инструмент присутствует. Торговый алгоритм портфелей будет вызываться в порядке возрастания $Order \; ID$, т.е. самым первым
		вызовется торговый алгоритм портфеля с $Order \; ID = a$, а самым последним -- с $Order \; ID = z$, при совпадении $Order \; ID$ у разных портфелей порядок вызова
		торгового алгоритма портфелей с одинаковым $Order \; ID$ НЕ определен и будет произвольным;
	\item \textbf{Hedge (sec)} -- интервал времени в секундах по прошествии которого автоматически хеджировать незахеджированную позицию (значение $-1$
		-- не использовать данный параметр);
	\item \textbf{Type} -- тип торгового алгоритма портфеля:
		\begin{itemize}
		\item \textit{Arbitrage} -- обычная арбитражная торговля с использованием всех заданных параметров;
		\item \textit{Option hedge} -- режим хеджирования, $Count$ всех инструментов кроме $Is \; first$ равен $1$, $Count$ для $Is \; first$ инструмента задается как
			$\frac{1}{delta}$, где $delta$ -- ''грек'', вычисляемый с использованием модели Блека-Шоулза, $Is \; first$ инструмент в таком режиме должен быть опционом;
		\item \textit{Test algo} -- тестовый режим для проверки скорости работы ''движков'' подключений на получение рыночных данных и на выставление заявок,
			использовать данный режим без обращения к технической поддержке НЕ рекомендуется, прибыли он НЕ приносит;
\ifdefined \Ramiz
		\item \textit{TP algo} -- режим работы с выставление \textit{take profit} заявки по главному инструменту \textit{(доступно НЕ во всех версиях программы)};
		\item \textit{TP algo 2} -- режим работы с выставление \textit{take profit} заявки по главному инструменту после каждой сделки (не по этой \textit{take profit}
			заявке), у выставленной заявки есть \textit{Timer} и \textit{SL} \textit{(доступно НЕ во всех версиях программы)};
\else
\fi
		\end{itemize}
	\item \textbf{Type trade} -- тип торговли, используется при расчете цен $Sell$, $Buy$, $Price\_s$, $Price\_b$:
		\begin{itemize}
		\item \textit{Price} -- режим торговли с расчетом вышеперечисленных цен по ценам инструментов на покупку и продажу;
		\item \textit{IV} -- режим торговли с расчетом вышеперечисленных цен по \textit{implied volatility} инструментов с использованием модели Блека-Шоулза;
		\end{itemize}
	\item \textbf{Overlay} -- хеджировать только если разница (в портфелях) между $Is \; first$ бумагой и остальными инструментами портфеля больше или равна значению данного
		параметра (в штуках портфелей, то есть в той же размерности, что и $v\_in\_left$ и $v\_in\_right$);
	\item \textbf{Type price} -- тип определения цены инструмента \textit{(доступно НЕ во всех версиях программы)}:
		\begin{itemize}
		\item \textit{Bid/offer} -- использовать лучшую цену на покупку и лучшую цену на продажу;
		\item \textit{Orderbook} -- искать цену в стакане, таким образом, чтобы набрать необходимый объем $Count \times Percent \; of \; quantity \times 0.01 \times \begin{cases} v\_in\_left, & \mbox{if } open \; pos \\ v\_out\_left, & \mbox{if } close \; pos \end{cases}$,
			набирать цены на покупку и продажу среди цен в стакане, начиная от лучшей цены в нужном направлении и далее вглубь стакана;
		\item \textit{Orderbook+filter} -- аналогично \textit{Orderbook}, но вычитать из набираемого объема цены своих заявок (если на соответствующих
			ценах присутствуют свои заявки);
		\end{itemize}
	\item \textbf{Custom trade} -- использовать \textit{Trade formula} для подсчета раздвижки в таблице с финансовыми результатами \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Trade formula} -- формула на языке программирования C++ для подсчета раздвижки в таблице с финансовыми результатами, вы пишете только тело функции
			и должны вернуть значение типа \textit{double} \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Simply first} -- если флаг взведен, то если цены \textit{Price\_s} и \textit{Price\_b} попадают в спред или на противоположную сторону стакана, то они всегда будут выставляться не глубже, чем на один шаг цены в спред:
		\begin{align*}
			Price\_s_1 = \max(Price\_s_0, offer - step), \\
			Price\_b_1 = \min(Price\_b_0, bid + step), 
		\end{align*}
		где \textit{bid}, \textit{offer}, \textit{step} -- это бид, оффер и шаг цены по \textit{Is first} бумаге, нижний индекс $0$ означает текущее значение параметра, нижний индекс $1$ означает
		новое значение параметра; если у $Is \; first$ бумаги взведен флаг $Maker$ и текущий спред в стакане равен одному шагу цены, то заявка на продажу будет выставлена по цене
		$offer$, а на покупку -- по цене $bid$ (в противном случае заявка просто не смогла бы выставиться и ''спамила'' бы биржу, что не хорошо) \textit{(доступно НЕ во всех версиях программы)};
	
	\textit{\underline{Важно}: если наша заявка становится бидом или оффером, при этом является единственной заявкой на данном ценовом уровне и цена следующего
		уровня стакана отличается от цены нашей заявки более чем на один шаг цены, то заявка снимается и далее выставляется по ценам, описанным выше.}
\ifdefined \Ramiz
	\item \textbf{Always timer} -- всегда использовать \textit{Limits timer}, даже тогда, когда можно торговать и происходит выставление заявки \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Equal prices} -- выставлять вторую ногу по такой цене, чтобы $Sell = Lim\_Sell$ и $Buy = Lim\_Buy$ (работает только для портфелей с двумя бумагами) \textit{(доступно НЕ во всех версиях программы)};
\else
\fi
	\item \textbf{Max not hedged} -- максимальное количество не захеджированных открытий по $Is \; first$ инструменту
		(т.е. когда по любому из не $Is \; first$ инструментов ''висит'' в рынке не менее, чем \textit{Max not hedged} активных заявок), после которого
		торговля по $Is \; first$ инструменту будет остановлена до тех пор пока хотя бы одна из незахеджированных позиций не захеджируется;
		
	\textit{\underline{Важно}: даже если $Max \; not \; hedged = 1$ и по какой-то причине не выставились заявки по не $Is \; first$ бумагам,
		то позиция будет автоматически выравнена при следующей сделке по $Is \; first$ бумаге (если снова не будет ошибок выставления) и, соответственно,
		торговля будет разрешена при НЕ ровной позиции портфеля (до тех пор пока позиция снова не станет ровной). То есть разрешено торговать при НЕ ровной
		позиции, НО только в случае ошибок выставления не $Is \; first$ инструментов.}

	\item \textbf{Extra formulas} -- флаг, включает рассчет \textit{Extra field\#1} и \textit{Extra field\#2} \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Extra field\#1} -- формула на языке программирования C++, вы пишете только тело функции
		и должны вернуть значение типа \textit{double} (нигде в алгоритме никак не используется, чтобы активировать, используйте флаг \textit{Extra formulas}) \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Extra field\#2} -- формула на языке программирования C++, вы пишете только тело функции
		и должны вернуть значение типа \textit{double} (нигде в алгоритме никак не используется, чтобы активировать, используйте флаг \textit{Extra formulas}) \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Color} -- цвет ячейки таблицы, используемый для боле удобной ''идентификации'' портфеля.
\end{enumerate}

\phantomsection
\noindent\label{comment0}\textit{\underline{Замечание 0:} значение параметра $right$ должно быть больше или равно значения параметра $left$ (иначе просто
торговать не будет), это условие НЕ проверяется в клиентской части. Для всех не $Is \; first$ инструментов вычисляется количество портфелей которое
возможно выставить по каждому из этих инструментов, по формуле:
\[
	v_i = \frac{amount_i \times 100}{Percent \; of \; quantity_i \times Count_i},
\]
где $amount_i$ -- объем лучшей цены на покупку/продажу в зависимости от направления торговли. После этого вычисляется $\displaystyle v = \min_i v_i$, это
объем заявки в штуках портфелей, на который хватает бумаг в рынке. Далее вычисляется $q$ -- итоговый выставляемый объем заявки в штуках портфелей
существует несколько случаев:}
\begin{itemize}
	\item \textit{вычисляем объем заявки на покупку}
	\begin{itemize}
		\item[\scriptsize$\blacksquare$]\textit{текущая позиция больше или равна нуля:}
			
			\textit{если включен режим $To0$, то $q=0$, иначе если $v \geq v\_in\_left$ или $count_{first} \times v \geq v\_max - pos_{first}$, то
			$q=min(count_{first} \times min(v\_in\_r, v), v\_max - pos_{first}, \abs{pos_{first}})$, если включен режим $virtual\_0\_pos$ и $q < count_{first} \times v\_in\_l$,
			то $q=0$; иначе $q=0$}
		\item[\scriptsize$\blacksquare$]\textit{текущая позиция меньше нуля:}
			
			\textit{если $v \geq v\_out\_l$ или $count_{first} \times v \geq v\_max - curpos_{first}$ или $count_{first} \times v \geq \abs{pos_{first}}$, то
			$q=min(count_{first} \times min(v\_out\_right, v), v\_max - pos_{first}, \abs{pos_{first}})$, если включен режим $virtual\_0\_pos$ и
			$q < count_{first} \times v\_out\_l$, то если $v \geq v\_out\_left$ и $0 \leq pos_{first} + count_{first} \times v\_out\_left \leq v\_max$, то
			$q = count_{first} \times v\_out\_l$ иначе $q=0$; иначе $q=0$}
	\end{itemize}
	\item \textit{вычисляем объем заявки на продажу}
	\begin{itemize}
		\item[\scriptsize$\blacksquare$]\textit{текущая позиция меньше или равна нуля:}
		
			\textit{если включен режим $To0$, то $q=0$, иначе если $v \geq v\_in\_left$ или $count_{first} \times v \geq -v\_min + pos_{first}$, то
			$q=min(count_{first} \times min(v\_in\_r, v), -v\_min + pos_{first}, \abs{pos_{first}})$, если включен режим $virtual\_0\_pos$ и $q < count_{first} \times v\_in\_l$,
			то $q=0$; иначе $q=0$}
		\item[\scriptsize$\blacksquare$]\textit{текущая позиция больше нуля:}
			
			\textit{если $v \geq v\_out\_l$ или $count_{first} \times v \geq -v\_min + curpos_{first}$ или $count_{first} \times v \geq \abs{pos_{first}}$, то
			$q=min(count_{first} \times min(v\_out\_right, v), -v\_min + pos_{first}, \abs{pos_{first}})$, если включен режим $virtual\_0\_pos$ и
			$q < count_{first} \times v\_out\_l$, то если $v \geq v\_out\_left$ и $v\_min \leq pos_{first} - count_{first} \times v\_out\_left \leq 0$, то
			$q = count_{first} \times v\_out\_l$ иначе $q=0$; иначе $q=0$}
	\end{itemize}
\end{itemize}
\textit{Где $count_{first}$ -- $Count$ $Is \; first$ бумаги, $pos_{first}$ -- $Curpos$ $Is \; first$ бумаги.\newline}

%Потом в
%зависимости от того входим мы в позицию или выходим из позиции, используются соответствующие отрезки: $\left [ v\_in\_left , v\_in\_right \right ]$, 
%$\left [ v\_out\_left , v\_out\_right \right ]$. Обозначим левую границу используемого отрезка $v\_left$, а правую -- $v\_right$. В случае, если $v$
%принадлежит выбранному отрезку, то выставляется $v$ портфелей; если $v$ строго больше правой границы отрезка ($v\_right$), то выставляется $v\_right$
%портфелей; если же $v$ строго меньше левой границы отрезка, то при выключенном $Virtual \; 0 \; pos$ заявка по $Is \; first$ инструменту НЕ выставляется,
%кроме случаев, когда ''расстояние'' до нуля или до $v\_min$ или $v\_max$, соответственно, меньше, чем $v\_left$, в таком случае объем заявки задается
%так, чтобы свести позицию к нулю, $v\_min$ или $v\_max$, соответственно.

%Если v закрывает позу и открывает новую
%Если же $v$ строго меньше левой границы отрезка и включен $Virtual \; 0 \; pos$, заявка сводит позицию к нулю то итоговое значение $v$ вычисляется по формуле $v_{real}$,

%\newline}

\phantomsection
\noindent\label{comment1}\textit{\underline{Замечание 1:} $v\_min$ и $v\_max$ задаются НЕ в той же размерности, что позиция портфеля ($Pos$).\newline}

\phantomsection
\noindent\label{comment2}\textit{\underline{Замечание 2:} рекомендуется, чтобы значение параметра $K$ было больше, чем значение параметра $K1$ ($K > K1$), в противном случае,
исходя из правил изменения цен $Lim\_Sell$ и $Lim\_Buy$, вы можете получить $Lim\_Buy > Lim\_Sell$, и робот будет продавать дешевле, чем покупает.}

\csection{Параметры портфеля (отображаемые)}
\begin{enumerate}
	\item \textbf{Sell} -- расчетная цена на продажу;
	\item \textbf{Buy} -- расчетная цена на покупку;
	\item \textbf{Price\_s} -- цена выставления заявки на продажу по $Is \; first$ бумаге, вычисляется как обратная функция для $Sell$, где цена $Sell$ заменяется на $Lim\_Sell$;
	\item \textbf{Price\_b} -- цена выставления заявки на покупку по $Is \; first$ бумаге, вычисляется как обратная функция для $Buy$, где цена $Buy$ заменяется на $Lim\_Buy$;
	\item \textbf{Sell status} -- статус заявки на продажу по $Is \; first$ бумаге (не используется при выставлении заявки с помощью ''кликеров''). Для того чтобы освободить
		''зависшую'' заявку, необходимо сделать двойной клик на ячейке таблицы. Ручная смена статуса может привести к потере заявки роботом, данную операцию рекомендуется делать
		только в крайних случаях;
	\item \textbf{Buy status} -- статус заявки на покупку по $Is \; first$ бумаге (не используется при выставлении заявки с помощью ''кликеров''). Для того чтобы освободить
		''зависшую'' заявку, необходимо сделать двойной клик на ячейке таблицы. Ручная смена статуса может привести к потере заявки роботом, данную операцию рекомендуется делать
		только в крайних случаях;
	\item \textbf{Start nearest} -- ближайшее по расписанию время автоматического включения портфеля;
	\item \textbf{Stop nearest} -- ближайшее по расписанию время автоматического выключения портфеля;
	\item \textbf{Avg opened} -- вычисляется по формуле $Avg \; opened = Opened / Pos$;
	\item \textbf{Return first} -- оборот по $Is \; first$ бумаге, вычисляется с момента старта серверной части робота как сумма модулей количеств лотов
		в сделках по $Is \; first$ инструменту;
	\item \textbf{Fin res} -- предполагаемый финансовый результат портфеля, вычисляется по формуле:
		\begin{align*}
		Fin \; res = Opened + Commission \; sum + \sum_{i \in secs}Curpos_i \times Mult_i \times \begin{cases} secBid_i, & \mbox{if } Curpos_i > 0 \\ secOffer_i, & \mbox{if } Curpos_i < 0 \end{cases},
		\end{align*} 
		где $secBid_i$ -- лучшая цена на покупку инструмента портфеля, $secOffer_i$ -- лучшая цена на продажу инструмента портфеля, $Curpos_i$ -- текущая позиция инструмента
		портфеля, $Mult$ -- $Fin \; res \; multiplier$ инструмента портфеля, $secs$ -- список инструментов портфеля. Двойной клик по ячейке в таблице
		переключает отображение финансового результата с учетом комиссии или без ее учета (финансовый результат без учета комиссии выделен жирным шрифтом);
	\item \textbf{Extra field\#1} -- просто отображаемое значение, рассчитываемое по соответствующей пользовательской формуле \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Extra field\#2} -- просто отображаемое значение, рассчитываемое по соответствующей пользовательской формуле \textit{(доступно НЕ во всех версиях программы)}.
\end{enumerate}

\csection{Параметры инструментов портфеля (всегда редактируемые, если не указано обратное)}
\begin{enumerate}
	\item \textbf{SecKey} -- уникальный идентификатор инструмента портфеля (не редактируемый);
	\item \textbf{SecBoard} -- режим инструмента портфеля (не редактируемый);
	\item \textbf{SecCode} -- код инструмента портфеля (не редактируемый);
	\item \textbf{SecType} -- тип инструмента (например, $CURR$ для валютного рынка) (не редактируемый);
	\item \textbf{Curpos} -- текущая позиция робота по данной бумаге в лотах;% (обновляется только при открытии/закрытии окна настроек)
	\item \textbf{Count} -- количество лотов инструмента в одном портфеле;
	\item \textbf{Count type} -- использовать $Count$ или $Count \; formula$ \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Count formula} -- количество лотов инструмента в одном портфеле, задается как код на языке программирования С++, вы пишете только тело функции,
		и должны вернуть значение типа \textit{double} \textit{(доступно НЕ во всех версиях программы)};
		
		\textit{\underline{Важно}: значения $Count$ или $Count \; formula$ определяют соотношение именно между позициями инструментов портфеля (соотношение в конкретной
		сделке может отличаться). По этой же причине значение $Count \; formula$ не зависит от направления выставляемой заявки.}

		\textit{\underline{Важно}: настоятельно рекомендуется для \textit{Is first} бумаги никогда не возвращать значение $0$, если вы хотите не торговать,
		используйте \textit{Ratio formula} и задавайте необходимые значения для раздвижки. Если вы все-таки получили \textit{Count} равный $0$ для \textit{Is first}
		бумаги, то портфель не будет торговать ни одной бумагой и для подсчета позиции портфеля в том месте где необходимо поделить на \textit{Count}
		\textit{Is first} бумаги (который в вашем случае равен $0$) будет делиться на $1$.}
	\item \textbf{k} -- используется для определения цены выставления заявки по алгоритму (отступ от рыночной цены (в пунктах), т.е. при покупке цена выставления $offer + k$, при
		продаже цена выставления $bid - k$, где $bid$ и $offer$ -- лучшие цены на продажу и покупку, соответственно);
	\item \textbf{On buy} -- определяет покупаем мы или продаем инструмент при срабатывании сигнала на покупку по главному инструменту портфеля;
	\item \textbf{Is first} -- определяет главный инструмент портфеля, этот инструмент выставляется первым и позиция портфеля считаемся по нему;
	\item \textbf{SLE}\hyperref[comment3]{\ref{comment3}\textsuperscript{3}} -- включить/выключить функцию переставления по стоп-лоссу;
	\item \textbf{SL}\hyperref[comment3]{\ref{comment3}\textsuperscript{3}} -- значение стоп-лосса (в пунктах), при достижении которого необходимо снимать заявку, если она не прошла
		до этого момента и бросать снова
		по новой рыночной цене (стоп-лосс откладывается от первоначальной цены выставления заявки);	
	\item \textbf{k\_sl}\hyperref[comment3]{\ref{comment3}\textsuperscript{3}} -- аналог параметра $k$ для работы по стоп-лоссу и по таймеру;
	\item \textbf{TE}\hyperref[comment3]{\ref{comment3}\textsuperscript{3}} -- включить/выключить функцию переставления по таймеру;
	\item \textbf{Timer}\hyperref[comment3]{\ref{comment3}\textsuperscript{3}} -- параметр, определяющий через сколько времени снимать заявку, если она не прошла до этого
		момента и бросать снова по новой рыночной цене;
	\item \textbf{Percent of quantity} -- если на бирже в объеме лучшей цены на продажу или покупку (или в найденном объеме в стакане если $Type \; price = Orderbook$
		или $Type \; price = Orderbook + filter$), соответственно, есть нужное количество процентов (\%) от объема заявки
		инструмента не являющегося $Is \; first$ и это условие выполняется для всех не $Is \; first$ инструментов, то можно выставляться по $Is \; first$ инструменту;
	\item \textbf{Ratio sign} -- знак используемый перед параметром $Ratio$ при расчете цен $Sell$ и $Buy$, ''$+$'' или ''$\times$'';
	\item \textbf{Ratio} -- параметр, используемый при расчете цен $Sell$ и $Buy$;
	\item \textbf{Fin res multiplier} -- множитель, используется для подсчета финансового результата, чтобы привести все цены к одной размерности;
	\item \textbf{Commission type} -- параметр, определяющий тип расчета комиссии;
	\item \textbf{Commission} -- комиссия по инструменту, если $Comission \; type =$ ''\%'', то комиссия указывается в процентах от цены сделки, если $Comission \; type =$ ''pt'',
		то комиссия указывается в той же размерности, в которой считается финансовый результат по портфелю (например, для акции Сбербанка комиссия указывается
		в процентах и для большинства брокеров она равна $0.01\%$, а для фьючерса на акцию Сбербанка комиссия указывается в пунктах и равна $0.25$ пункта
		для скальперских сделок);
	\item \textbf{Client code}\hyperref[comment5]{\ref{comment5}\textsuperscript{5}} -- код клиента с которого надо выставлять заявку по данной бумаге или пустая строка если необходимо выставлять с ''кода по-умолчанию'',
		отображает все коды, которые прописаны в настройках робота, код \textit{To file} означает торговлю ''в файл''; код, начинающийся с \textit{Round robin}, означает выставление и снятие заявок поочередно через
		все подключения к бирже с заданным клиентским кодом, порядок подключений в очереди зависит от скорости выставления заявок через эти подключения (кто в данный момент быстрее, тот первый в очереди, порядок подключений
		в очереди меняется раз в секунду, кроме того каждую секунду движение по очередит начинается заново, т.о. загрузка подключений НЕ равномерная);
		
		\textit{\underline{Важно}: код клиента не может быть пустым для бумаг с \textit{Count} отличным от нуля.
Скорость параметра Round robin считается только по важным заявкам. Важными заявками являются: is first заявка, выставленная по алгоритму первой ноги (т.е не кликером, не стопом и прочими способами), либо по второй ноге брошенная по алгоритму после сделки по 1 ноге. Раз в час сбрасывается значение скоростей для того, чтобы проверить скорость высталения заявок всех подключений. }
	\item \textbf{MM} -- флаг, если взведен, то все заявки по инструменту выставляются с признаком ''заявка маркет-мейкера'' (доступно не для всех подключений);
\ifdefined \Ramiz
	\item \textbf{TP} -- величина тейк-профит, используется при $Type$ равном $TP \; algo$, откладывается от цены сделки по заявке $Is \; first$ инструмента \textit{(доступно НЕ во всех версиях программы)};
\else
\fi
	\item \textbf{Ratio type} -- использовать $Ratio$ или $Ratio \; formula$ \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Ratio sell formula} -- параметр, используемый при расчете цены $Sell$, задается как код на языке программирования С++, вы пишете только тело функции,
		и должны вернуть значение типа \textit{double} \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Ratio buy formula} -- параметр, используемый при расчете цены $Buy$, задается как код на языке программирования С++, вы пишете только тело функции,
		и должны вернуть значение типа \textit{double} \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{FUT move limits}\hyperref[comment4]{\ref{comment4}\textsuperscript{4}} -- флаг, если взведен, то при каждой смене дня будет осуществляться автоматическая ''подвижка'' лимитов по формулам:
		\begin{align*}
			Lim\_Sell_1 = Lim\_Sell_0 - \frac{\left( Lim\_Sell_0 + Lim\_Buy_0 \right) \times days\_to\_expiry_{SPOT}}{2 \times days\_to\_expiry},\\
			Lim\_Buy_1 = Lim\_Buy_0 - \frac{\left( Lim\_Sell_0 + Lim\_Buy_0 \right) \times days\_to\_expiry_{SPOT}}{2 \times days\_to\_expiry},
		\end{align*}
		где $days\_to\_expiry$ -- целое количество дней до экспирации данной бумаги, $days\_to\_expiry_{SPOT}$ -- целое количество дней до экспирации бумаги,
		отмеченной флагом \textit{SPOT move limits}, или $1$, если такая бумага не указана, нижний индекс $0$ означает текущее значение параметра, нижний индекс $1$ означает
		новое значение параметра;
	\item \textbf{SPOT move limits}\hyperref[comment4]{\ref{comment4}\textsuperscript{4}} -- флаг, если взведен, то данная бумага используется в формулах для \textit{FUT move limits};	
	\item \textbf{Depth OB} -- максимальный уровень глубины стакана (в штуках шагов цены, считая от бида/оффера) до которого включительно вычислять цены и объемы, доступен только для не \textit{Is first} бумаг,
		используется только в режимах $Type \; price = Orderbook$ и $Type \; price = Orderbook + filter$ \textit{(доступно НЕ во всех версиях программы)};
	\item \textbf{Calc price OB} -- тип цены, используемой для расчета \textit{Sell}, \textit{Buy}, \textit{Price\_s}, \textit{Price\_b}, доступен только для не \textit{Is first} бумаг,
		используется только в режимах $Type \; price = Orderbook$ и $Type \; price = Orderbook + filter$ \textit{(доступно НЕ во всех версиях программы)}:
		\begin{itemize}
			\item \textit{Deepest} -- цена того уровня в стакане, на котором набрали искомый объем;
			\item \textit{Weighted avg.} -- средневзвешенная цена до того уровня в стакане включительно, на котором набрали искомый объем;
		\end{itemize}
	\item \textbf{Trading price OB} -- тип цены, используемой при торговле, доступен только для не \textit{Is first} бумаг,
		используется только в режимах $Type \; price = Orderbook$ и $Type \; price = Orderbook + filter$ \textit{(доступно НЕ во всех версиях программы)}:
		\begin{itemize}
			\item \textit{Deepest} -- цена того уровня в стакане, на котором набрали искомый объем;
			\item \textit{Weighted avg.} -- средневзвешенная цена до того уровня в стакане включительно, на котором набрали искомый объем;
		\end{itemize}
	\item \textbf{Level to0} -- если хотя бы для одной бумаги портфеля модуль разности \textit{Mark price} и \textit{Liquidity price} строго меньше данного
		значения, то взвести флаг \textit{To0} и НЕ давать его снять пока условие выполняется, когда условие перестанет выполняться -- снять флаг \textit{To0} \textit{(доступно НЕ во всех версиях программы, имеет смысл только для бумаг с BitMEX, Deribit, Cryptofacilities)};
	\item \textbf{Level close} -- если хотя бы для одной бумаги портфеля модуль разности \textit{Mark price} и \textit{Liquidity price} строго меньше данного
		значения, то взвести флаг \textit{To0} и НЕ давать его снять пока условие выполняется (когда условие перестанет выполняться -- снять флаг \textit{To0}), раз в $5$ секунд выставлять заявку в направлении закрытия позиции
		в объеме \textit{v\_out\_left} портфелей до тех пор пока описанное выше условие не перестанет выполняться или позиция по портфелю не станет равн $0$ \textit{(доступно НЕ во всех версиях программы, имеет смысл только для бумаг с BitMEX, Deribit, Cryptofacilities)};
	\item \textbf{Only maker} -- выставлять котирующие (т.е. при включенном режиме $Quote$) заявки по $Is \; first$ бумаге с признаком ''снять если заявка будет taker'' \textit{(это параметр заявки, не работает на московской и питерской бирже так как они данный параметр не поддерживают; имеет смысл только для бумаг с BitMEX, Bitfinex, Deribit, Cryptofacilities)};
	\item \textbf{Decimals} -- параметр, определяющий сколько знаков после десятичной точки отображается в параметрах, для которых значение является дробным числом.
		
	\textit{\underline{Важно}: данный параметр так же отвечает за число знаков после десятичной точки в ценах сделок по данной бумаге в таблице раздвижек. При смене значения, число знаков у уже добавленных в таблицу сделок НЕ изменится.}
\end{enumerate}

\phantomsection
\noindent\label{comment3}\textit{\underline{Замечание 3:} параметры $TE$, $Timer$, $SLE$, $SL$, $k\_sl$ не используются для бумаги $Is \; first$ при торговле по алгоритму.
Используются только при торговле с использованием ''кликеров'' ($Sell \; clicker$, $Buy \; clicker$).\newline}

\phantomsection
\noindent\label{comment4}\textit{\underline{Замечание 4:} алгоритм смещения Lim\_Sell/Lim\_Buy на размер ставки свопа по заданной паре, данная опция позволяет учитывать смещение Sell/Buy на размер овернайт.\newline}

\phantomsection
\noindent\label{comment5}\textit{\underline{Замечание 5:} торговля ''в файл'' реализована по аналогии с тестером:
		выставленные заявки проходят только в том случае, если, для покупки, цена заявки больше или равна текущей цене на продажу по данной
		бумаге и есть достаточное число бумаг на рынке, для продажи, если цена заявки меньше или равна текущей цене на покупку по данной бумаге и есть достаточное число бумаг на рынке (также учитывается параметр, отвечайщий за процент
		прохождения заявок, описанный ниже), причем ценами прохождения заявок ВСЕГДА являются
		лучшая цена на покупку и лучшая цена на продажу (или цены глубже в стакане, при наличии стакана) для данной бумаги (т.е. идейно это работает как будто мы всегда ''бьем'' по стоящим в стакане ценам).\newline}

\noindent\textit{\underline{Замечание 6:} в параметрах портфеля и в параметрах инструментов есть параметры с одинаковыми или очень похожими названиями, это РАЗНЫЕ параметры.}

\phantomsection
\label{portfolio_notifications}
\csection{Параметры уведомлений портфеля (редактируемые)}

Если возле названия уведомления присутствует иконка \raisebox{-1mm}{\includegraphics[height=6mm]{telegram}}, то это обновление будет приходить в telegram-бота.

\begin{enumerate}
	\item \textbf{Trades frequency notifications} -- уведомлять о большом количестве сделок ($>= Count$) по портфелю за $Time$ секунд:
	\begin{enumerate}
		\item \textbf{Trades freq type} -- тип расчета сигнального значения:
		\begin{itemize}
			\item \textit{Trades count} -- считать количество сделок;
			\item \textit{Trades quantity} -- считать суммарный объем сделок;
		\end{itemize}
	\item \textbf{Time (sec)} -- период времени, за который считать сигнальное количество сделок (откладывается назад от текущего времени);
		\item \textbf{Count} -- сигнальное количество сделок или сигнальный суммарный объем сделок (в зависимости от $Trades \; freq \; type$);
	\end{enumerate}
	\item \textbf{FinRes fall notifications} -- уведомлять о падении финансового результата по портфелю за $Time$ секунд, то есть когда текущий финансовый
		результат $> max ( Min \; fall, Fin \; res_{saved} - \abs{Fin \; res_{saved} \times Fall \times 0.01} )$, где $Fin \; res_{saved}$ -- ''эталонный''
		финансовый результат сохраняемый (обновляемый) каждые $Time$ секунд:
	\begin{enumerate}
		\item \textbf{Time (sec)} -- период времени в секундах, откладываемый от момента включения робота или редактирования параметров, влияющих на
			вычисление финансового результата, с указанной периодичностью будет обновляться ''эталонный'' финансовый результат;
		\item \textbf{Min fall (pt)} -- если процентное изменение финансового результата меньше данной величины, то не уведомлять;
		\item \textbf{Fall (\%)} -- процентное изменение ''эталонного'' финансового результата о достижении которого необходимо уведомить пользователя;
		\item \textbf{Stop trading} -- вместе с уведомлением выключить торговлю по портфелю (расписание также будет выключено);
	\end{enumerate}
	\item \textbf{Lim\_Sell change notifications} -- уведомлять об изменении $Lim\_Sell$ портфеля за $Time$ секунд больше, чем на $Value$:
	\begin{enumerate}
		\item \textbf{Time (sec)} -- период времени в секундах, не чаще, чем с указанной периодичностью, будет обновляться ''эталонный'' $Lim\_Sell$;
		\item \textbf{Value} -- сигнальное значение изменения $Lim\_Sell$;
		\item \textbf{Stop trading} -- вместе с уведомлением выключить торговлю по портфелю (расписание также будет выключено);
	\end{enumerate}
	\item \textbf{Lim\_Buy change notifications} -- уведомлять об изменении $Lim\_Buy$ портфеля за $Time$ секунд больше, чем на $Value$:
	\begin{enumerate}
		\item \textbf{Time (sec)} -- период времени в секундах, не чаще, чем с указанной периодичностью, будет обновляться ''эталонный'' $Lim\_Buy$;
		\item \textbf{Value} -- сигнальное значение изменения $Lim\_Buy$;
		\item \textbf{Stop trading} -- вместе с уведомлением выключить торговлю по портфелю (расписание также будет выключено);
	\end{enumerate}
	\item \textbf{Severe sell change notification} -- уведомлять о ''резком'' изменении $Sell$ портфеля ($\geq Value$) за $Time$ секунд (только когда портфель
		включен):
	\begin{enumerate}
		\item \textbf{Time (sec)} -- период времени, за который считать изменение $Sell$ (откладывается назад от текущего времени) как разницу между текущим
			$Sell$ и $Sell$ $Time$ секунд назад;
		\item \textbf{Value} -- сигнальное значение изменения $Sell$;
	\end{enumerate}
	\item \textbf{Severe buy change notification} -- уведомлять о ''резком'' изменении $Buy$ портфеля ($\geq Value$) за $Time$ секунд (только когда портфель
		включен):
	\begin{enumerate}
		\item \textbf{Time (sec)} -- период времени, за который считать изменение $Buy$ (откладывается назад от текущего времени) как разницу между текущим
			$Buy$ и $Buy$ $Time$ секунд назад;
		\item \textbf{Value} -- сигнальное значение изменения $Buy$;
	\end{enumerate}
	\item \textbf{Severe pos change notification} -- уведомлять о ''резком'' изменении позиции ($Pos$) по портфелю ($\geq Value$) за $Time$ секунд:
	\begin{enumerate}
		\item \textbf{Time (sec)} -- период времени, за который считать изменение позиции (откладывается назад от текущего времени) как разницу между текущей
			позицией и позицией $Time$ секунд назад;
		\item \textbf{Value} -- сигнальное значение изменения позиции;
	\end{enumerate}
	\item \textbf{Too much running orders notification} -- уведомлять о слишком большом количестве активных заявок по не $Is \; first$ инструментам портфеля
		($max$ (число активных заявок по каждому из не $Is \; first$ инструментов портфеля) $\geq Percent \times Max \; not \; hedged \times 0.01$, где $Max \; not \; hedged$ по-умолчанию равен $30$):
	\begin{enumerate}
		\item \textbf{Percent (\%)} -- сигнальный процент;
	\end{enumerate}
	\item \textbf{Too much not hedged notification} -- уведомлять о слишком большой не захеджированной позиции по $Is \; first$ инструменту портфеля:
	\begin{enumerate}
		\item \textbf{Limit portfolios} -- сигнальное значение не захеджированной позиции (вычисляется в штуках портфелей).
	\end{enumerate}
\end{enumerate}

\csection{Порядок выставления заявок и механизм выравнивания позиции}
Робот выставляет заявку по $Is \; first$ бумаге при торговле в режиме $Quote$ в зависимости от настроек, но независимо от сигналов на продажу/покупку, по $Lim\_Sell$/$Lim\_Buy$
или по сигналам $Lim\_Sell$/$Lim\_Buy$ (условие для выставления было описано ранее) при выключенном режиме $Quote$. При прохождении сделки по $Is \; first$ бумаге выставляются
заявки по остальным инструментам портфеля, направление заявок определяется направлением сделки по $Is \; first$ бумаге а также значением параметра $On \; buy$ $Is \; first$ и не
$Is \; first$ инструмента. Объем для выставления каждого не $Is \; first$ инструмента вычисляется исходя из текущей позиции в портфеле по $Is \; first$ бумаге и $Count$
как по $Is \; first$ бумаге так и по текущей, таким образом чтобы отношение ''новой'' (которая будет после прохождения сделки по еще невыставленной, но выставляемой в
данный момент заявке) позиции текущей бумаги к позиции по $Is \; first$ бумаге было равно отношению $Count$ не $Is \; first$ бумаги к $Count$ $Is \; first$ бумаги. Причем если
по данному инструменту в данном портфеле есть неисполненные заявки, то они учитываются как исполненные при определении ''новой'' позиции по данной не $Is \; first$ бумаге.

\vspace{4mm}
\noindent\textit{\underline{Важно}: Робот всегда выставляет лимитные котировочные заявки. Для $Is \; first$ инструмента ценами выставления являются: 
$Price\_s - k$ на продажу и $Price\_b + k$ на покупку. Для не $Is \; first$ инструментов ценами выставления являются (для основной ветки алгоритма):
$bid - k$ на продажу и $offer + k$ на покупку.}

\csection{Правила перемещения $Lim\_Sell$ и $Lim\_Buy$}
Сигнальные цены $Lim\_Sell$ и $Lim\_Buy$ перемещаются только при прохождении сделок по $Is \; first$ инструменту портфеля.

Правила перемещения сигнальных цен можно разделить на две части: произошла продажа по $Is \; first$ бумаге и произошла покупка по $Is \; first$ бумаге. Внутри каждой из этих
частей алгоритм делится еще на две части: позиция портфеля до прохождения данной сделки была равна нулю и была не равна нулю.

Введем следующие обозначения: $diffpos$ -- знаковое количество лотов в сделке по $Is \; first$ бумаге, $V$ -- это $v\_in\_left \times Count$ или
$v\_out\_left \times Count$ в зависимости от того открываем мы позицию или закрываем данной заявкой, $Count$ -- это $Count$ $Is \; first$ бумаги,
$curpos$ -- текущая позиция по \textit{Is first} бумаге портфеля (т.е. прошедшая только что сделка еще НЕ учтена), нижний индекс $0$ -- предыдущее значение параметра, $1$ -- новое значение параметра. В данных обозначениях
алгоритм перемещения сигнальных цен примет вид:
\begin{itemize}
\item прошла продажа (соответственно, в количестве $diffpos$):
\begin{itemize}
\item[\scriptsize$\blacksquare$] $curpos \neq 0$:
	
	$k3 = \left(\abs{Lim\_Sell_0 - Lim\_Buy_0} - TP - K \right) \times \frac{V}{curpos}$ ,
	
	$k4 = \begin{cases} k3 + K2, & \mbox{if } Lim\_Sell_0 - Lim\_Buy_0 \geq 0 \\ -k3 + K2, & \mbox{if } Lim\_Sell_0 - Lim\_Buy_0 < 0 \end{cases}$ ,
	
	$Lim\_Buy_1 = Lim\_Buy_0 + \frac{\abs{diffpos}}{V} \times \begin{cases} k4, & \mbox{if } curpos > 0 \\ K1, & \mbox{if } curpos < 0 \end{cases}$ ,
	
	$Lim\_Sell_1 = Lim\_Sell_0 + \frac{\abs{diffpos}}{V} \times \begin{cases} K2, & \mbox{if } curpos > 0 \\ K, & \mbox{if } curpos < 0 \end{cases}$ ,
	
\item[\scriptsize$\blacksquare$] $curpos = 0$:
	
	$Lim\_Buy_1 = Lim\_Sell_0 - TP$ ,
	
	$Lim\_Sell_1 = Lim\_Sell_0 + \frac{\abs{diffpos}}{V} \times K$ ,
	
\end{itemize}
\item прошла покупка (соответственно, в количестве $diffpos$):
\begin{itemize}
\item[\scriptsize$\blacksquare$] $curpos \neq 0$:
	
	$k3 = \left(\abs{Lim\_Sell_0 - Lim\_Buy_0} - TP - K \right) \times \frac{V}{curpos}$ ,
	
	$k4 = \begin{cases} -k3 + K2, & \mbox{if } Lim\_Sell_0 - Lim\_Buy_0 \geq 0 \\ k3 + K2, & \mbox{if } Lim\_Sell_0 - Lim\_Buy_0 < 0 \end{cases}$ ,
	
	$Lim\_Sell_1 = Lim\_Sell_0 - \frac{\abs{diffpos}}{V} \times \begin{cases} k4, & \mbox{if } curpos < 0 \\ K1, & \mbox{if } curpos > 0 \end{cases}$ ,
	
	$Lim\_Buy_1 = Lim\_Buy_0 - \frac{\abs{diffpos}}{V} \times \begin{cases} K2, & \mbox{if } curpos < 0 \\ K, & \mbox{if } curpos > 0 \end{cases}$ ,
	
\item[\scriptsize$\blacksquare$] $curpos = 0$:
	
	$Lim\_Sell_1 = Lim\_Buy_0 + TP$ ,
	
	$Lim\_Buy_1 = Lim\_Buy_0 - \frac{\abs{diffpos}}{V} \times K$ .
	
\end{itemize}
\end{itemize}

Также перемещение сигнальных цен происходит когда заявка не может быть выставлена из-за ограничений по $v\_min$, $v\_max$, $To0$. Если робот не может купить из-за ограничений по
$v\_max$, то в соответствии с параметрами портфеля $Limits \; timer$ и $Percent$ цены $Lim\_Sell$ и $Lim\_Buy$ уменьшаются на величину параметра портфеля $K$, если же робот не может
продать из-за ограничений по $v\_min$, то в соответствии с параметрами портфеля $Limits \; timer$ и $Percent$ цены $Lim\_Sell$ и $Lim\_Buy$ увеличиваются на величину параметра
портфеля $K$.

\phantomsection
\label{algo_features}
\csection{Неочевидные моменты, связанные с работой робота}

\begin{enumerate}
	\item Если при срабатывании \textit{SL} или \textit{Timer} заявка не проходит в течение $1$ секунды, то она будет автоматически переставлена по цене $bid - k\_sl$ на продажу или $offer + k\_sl$
		на покупку, в независмости от значений \textit{SL} и \textit{Timer} и в не зависмости от того включен ли \textit{Timer} вообще.
	\item Заявки, выставляемые при закрытии или выравнивании позиции (это либо настройка в расписании, либо ''кликер'' \textit{To market}) всегда выставляются с включенным таймером
		и значение параметра \textit{Timer} для таких заявок всегда равно $1$.
	\item Финансовый результат (в смысле просто число) считается по сделкам и никаких ''экзотических'' случаев, связанных с его подсчетом нет.
		НО есть случаи когда не будет раздвижки в таблице финансовых результатов. Нужно запомнить главное правило, чтобы была раздвижка, должна быть сделка
		по главной бумаге, если ее нет, то и раздвижки нет. То есть, если у вас по какой-то причине ''кривая'' позиция и вы ее ''подравняли'', нажав на кнопку
		\textit{To market}, то вы не получите нормальной раздвижки в данной таблице. У вас будет только одна ''кривая'' раздвижка, в которой фигурирует
		только главная бумага (как пример, флуд контроль, проходят сделки по первой ноге, а по второй не дают выставиться, у вас будут одноногие ''кривые'' раздвижки
		с первой ногой, а после нажатия \textit{To market}, когда пройдут сделки, т.к. они были только по второй ноге, то раздвижки в таблице не будет, но с финансовым
		результатом все будет в порядке).
		
		И еще один вариант, это когда \textit{Count} первой ноги больше \textit{Count}-а второй. Т.е. пусть вы торгуете долларом валюты против доллара на
		срочном рынке, но валюта первая нога. Т.е. у вас стоит \textit{Count} у валюты $100$ (ну или $1000$, сколько там должно быть?, думаю, вы меня поняли),
		а у срочки $1$. Т.е. вы перекрываете на срочке каждые $100$ контрактов валютки. Вот вы выставили $100$ контрактов на валютке, у вас взяли $60$,
		раздвижки в таблице не будет, т.к. она получится заведомо ''кривой'', вторую ногу же не кидали, потом прошло еще $50$, и вы снова не увидите
		раздвижки. Да, вы кините одну бумагу на срочку, она пройдет (в финансовом результате все нормально учтется). Но опять же не совсем ясно к каким
		сделкам ее привязывать, если привязать как обычно к последней (т.е. к $50$), то будет заведомо ''кривая'' раздвижка, а искать какие-то предыдущие
		сделки уже не вариант, т.к. все могло быть не так просто, как в описанном примере.
	\item В момент выставлении заявки по \textit{is first} инструменту запоминаются текущие цены по не \textit{is first} бумагам. Таким образом в момент совершении сделки по \textit{is first} инструменту все остальные бумаги в портфеле выставятся по ценам которые робот запомнил во время выставления заявки по \textit{is first} инструменту.
\end{enumerate}

\csection{Пример работы программы с заданием основных параметров}

Пусть заданы следующие параметры:

\begin{itemize}
\item$Lim\_Sell= 700$,
\item$Lim\_Buy = 600$,
\item$TP = 50$,
\item$K  = 10$,
\item$K1 = 5$,
\item$K2 = 3$,
\item$v\_in\_left  = 100$,
\item$v\_in\_right  = 100$,
\item$v\_out\_left = 100$,
\item$v\_out\_right = 100$.
\end{itemize}

Если раздвижка дает ''нагружаться'' по $700$ и выше (т.е. $Sell \geq Lim\_Sell$), то будут проходить следующие сделки:
\begin{enumerate}
\item продажа $100$ портфелей по $700$,
\item продажа $100$ портфелей по $710$,
\item продажа $100$ портфелей по $720$,
\end{enumerate}

... и т.д., увеличивая уровень входа на $10$ (значение $K$),

\begin{enumerate}
\setcounter{enumi}{6}
\item продажа $100$ портфелей по $760$.
\end{enumerate}

\noindent $Lim\_Buy$ к моменту седьмой продажи будет подтягиваться каждый раз на $5$ пунктов (значение  $K1$), начиная  со второй продажи. После первой продажи $Lim\_Buy$
примет значение $650$ ($Lim\_Sell - TP$). В итоге ПОСЛЕ седьмого входа уровни на вход/выход примут следующий вид:
\begin{align*}
Lim\_Sell = 760 + K = 770, \;
Lim\_Buy = 700 - 50 + 5 + 5 + 5 + 5 + 5 + 5 = 680,
\end{align*}
где $760$ -- уровень последнего входа.


Для ''разгрузки'' используется коэффициент $K2$. При выходе из позиции по $Lim\_B$ сделки будут проходит на следующих уровнях:
\begin{enumerate}
\item покупка $100$ портфелей по $680$,
\item покупка $100$ портфелей по $677$,
\item покупка $100$ портфелей по $674$,
\end{enumerate}

... и т.д., уменьшая уровень выхода на $3$ (значение $K2$),

\begin{enumerate}
\setcounter{enumi}{6}
\item покупка $100$ портфелей по $662 = 680 - 3 - 3 - 3 - 3 - 3 - 3$.
\end{enumerate}
\noindent$Lim\_Sell$ при ''разгрузке'' будет плавно подтягиваться к $Lim\_Buy$ с учетом уже закрытых позиций таким образом, что когда позиция станет равна нулю, $Lim\_Sell$
примет значение $Lim\_Buy + TP$.

Уровни  $Lim\_Sell$ и $Lim\_Buy$ будут двигаться не на строго заданные значения ($K$, $K1$, $K2$) если объем проходит частями, например, если прошел не весь $v\_in\_left = v\_in\_right$, а
только половина, тогда уровень $Lim\_Sell$ и $Lim\_Buy$ сдвинется только на половину того значения, которое задано  коэффициентами $K$, $K1$, $K2$.

Для того, чтобы ''разгрузиться'' сразу на одном уровне необходимо задать коэффициент $K2 = 0$ (в таком случае подвижки $Lim\_Buy$ происходить не будет).
Для того, чтобы ''отгрузить'', например, $233$ контракта на уровне $680$, $233$ на $650$ и $233$ на $620$, необходимо коэффициенту $K2$ присвоить значение $8.57$ ($8.57 = (680 - 620) / 7$).
В действительности, робот  не будет держать твердые уровни $680$, $650$ и $620$, а будет плавно сдвигаться на $8.57$, в конечном итоге, достигая нужного уровня.

%\ifdefined \Ramiz
\newpage

\begin{center}
\rchapter{Написание формул на языке программирования C++}
\end{center}

\noindent\textit{\underline{Важно}: функционал, описываемый в данном разделе, доступен НЕ во всех версиях робота.\newline}

\input{\AppPath/../cpp/text/formulas.tex}

\phantomsection
\label{robot_formulas_examples}
\csection{Примеры написания \textit{Ratio buy/sell formula}}

При написании формул можно использовать все те инструменты (\hyperref[security]{\ref{security}security}), которые
используются в любом из портфелей, также можно использовать доступные значения других портфелей (\hyperref[portfolio]{\ref{portfolio}portfolio}),
например, их позиции по бумагам.

Для того, чтобы использовать поле \textit{Ratio buy/sell formula} необходимо для выбранного инструмента портфеля выбрать \textit{Ratio type} = \textit{Ratio formula}.
После этого двойным кликом войти в редактор и написать необходимое значение.\newline

Пусть имеется портфель с именем ''\textit{si}'' и в этом портфеле есть один инструмент -- фьючерс на доллар ''\textit{SiH6}'', направление торговли этого
инструмента $On \; buy = Buy$.

Если $Ratio \; sign$ = ''$\times$'', то ничего особо-то интересного с формулами не придумаешь, разве что какой-то хитрый множитель (и для покупки и для продажи), например, такой:
\begin{cpp}
return sqrt(S["SiH6"].bid);
\end{cpp}
в таком случае для расчета $Buy$ и $Sell$ будет использован один и тот же множитель, если же вы хотите использовать разные множители надо вписать разные значения
в \textit{Ratio buy formula} и \textit{Ratio sell formula}, например, так:
\begin{cpp}
return sqrt(S["SiH6"].bid);
\end{cpp}
и
\begin{cpp}
return sqrt(S["SiH6"].offer);
\end{cpp}
для покупки и продажи, соответственно.

в таком случае для расчета $Buy$ будет использован квадратный корень из бида, а для расчета $Sell$ будет использован квадратный корень из оффера.

Если же $Ratio \; sign$ = ''$+$'', то вы можете полностью изменить формулу расчета $Buy$ и $Sell$, для этого надо для начала вычесть те значения,
которые используются в данный момент, тем самым обнулив $Buy$ и $Sell$:
\begin{cpp}
return -S["SiH6"].offer;
\end{cpp}
и
\begin{cpp}
return -S["SiH6"].bid;
\end{cpp}
для покупки и продажи, соответственно, а после этого прибавить к $Buy$ и $Sell$ новое значение, например, так:
\begin{cpp}
double price = S["SiH6"].offer * 3 + 5;
return -S["SiH6"].offer + price;
\end{cpp}
и
\begin{cpp}
double price = S["SiH6"].bid * 3 + 5;
return -S["SiH6"].bid + price;
\end{cpp}
теперь значения переменной $price$ при расчете каждого из параметров будут новыми значениями для $Buy$ и $Sell$. Хочется отметить, что без использования \textit{Ratio formula}
такое ''хитрое'' значение получить бы не удалось.\newline

Рассмотрим еще один пример. Пусть имеется портфель с именем ''\textit{test}'' и в этом портфеле есть два инструмента: фьючерс на доллар ''\textit{SiH6}'',
направление торговли этого инструмента $On \; buy = Buy$ и он является $Is \; first$ и фьючерс на индекс РТС ''\textit{RIH6}'', направление торговли
этого инструмента тоже $On \; buy = Buy$ (для примера направление не $Is \; first$ инструмента значения не имеет). Для того чтобы использовать эти два
инструмента в одном портфеле нужно привести их цены в пунктах к одной размерности, как известно, доллар торгуется в рублях ($1 \;pt = 1 \; rub$), а вот
индекс торгуется не в рублях, для него $1 \;pt = 0.02 \times \$_{price} \; rub$ (где $\$_{price}$ -- это курс доллара в рублях, но это не константа а динамически
изменяющаяся величина). Есть два варианта решения поставленной задачи, оба реализуемы только с использованием \textit{Ratio formula} и оба приводят к
абсолютно одинаковому результату. Вот они:
\begin{enumerate}
	\item для доллара просто зададим $Ratio = 1$, а вот для индекса РТС выберем $Ratio \; sign$ = ''$\times$'', а в \textit{Ratio buy formula} напишем следующее:
	\begin{cpp}
return (0.02 * S["SiH6"].offer * 0.001);
	\end{cpp}
	в \textit{Ratio sell formula} напишем следующее:
	\begin{cpp}
return (0.02 * S["SiH6"].bid * 0.001);
	\end{cpp}
	таким образом при расчете $Buy$ мы будем использовать бид доллара, а при расчете $Sell$ -- его оффер, и величину получим в рублях
	\item для доллара просто зададим $Ratio = 1$, а вот для индекса РТС выберем $Ratio \; sign$ = ''$+$'', а в \textit{Ratio buy formula} напишем следующее
	(вначале обнулим значение, как в предыдущем примере, а затем зададим новое):
	\begin{cpp}
double price = S["RIH6"].offer * 0.02 * S["SiH6"].offer * 0.001;
return -S["RIH6"].offer + price;
	\end{cpp}
	в \textit{Ratio sell formula} напишем следующее:
	\begin{cpp}
double price = S["RIH6"].bid * 0.02 * S["SiH6"].bid * 0.001;
return -S["RIH6"].bid + price;
	\end{cpp}
	теперь значения переменной $price$ и будут новыми значениями (так сказать, со стороны индекса РТС), используемыми для расчета $Buy$ и $Sell$, соответственно.
\end{enumerate}
%\else
%\fi
